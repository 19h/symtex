use api::gen::api::v1::{
    AgentMode as ApiAgentMode, AgentReport, AgentState as ApiAgentState, Task, UnitQuaternion, Vec3m,
    Vec3mps,
};
use nalgebra::{Isometry3, Point3, UnitQuaternion as NalgebraUnitQuaternion, Vector3};
use roaring::RoaringBitmap;
use std::time::Duration;

const AGENT_SPEED_MPS: f64 = 10.0; // 10 m/s
const WAYPOINT_PROXIMITY_M: f64 = 1.0; // 1 meter

/// The operational mode of the agent, representing its current state.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Mode {
    AwaitingTask,
    Planning,
    Navigating,
    Perceiving,
    Shutdown,
}

/// A navigation plan generated by the agent.
#[derive(Debug, Clone)]
pub struct Plan {
    pub waypoints: Vec<Point3<f64>>,
}

/// The central state machine for the simulated agent.
///
/// This struct holds all runtime state, including its physical pose,
/// current task, and discovery data.
pub struct AgentMachine {
    pub agent_id: u64,
    pub pose: Isometry3<f64>,
    pub velocity: Vector3<f64>,
    pub mode: Mode,
    pub current_task: Option<Task>,
    pub current_plan: Option<Plan>,
    pub discovery_buffer: RoaringBitmap,
    sequence_number: u32,
}

impl AgentMachine {
    /// Creates a new `AgentMachine` in an initial state.
    pub fn new(agent_id: u64) -> Self {
        Self {
            agent_id,
            pose: Isometry3::identity(),
            velocity: Vector3::zeros(),
            mode: Mode::AwaitingTask,
            current_task: None,
            current_plan: None,
            discovery_buffer: RoaringBitmap::new(),
            sequence_number: 0,
        }
    }

    /// Assigns a new task to the agent and transitions it to the `Planning` state.
    pub fn assign_task(&mut self, task: Task) {
        self.current_task = Some(task);
        self.mode = Mode::Planning;
        tracing::info!(task = ?self.current_task, "Assigned new task, entering planning mode");
    }

    /// Executes a single step of the agent's logic and state transitions.
    pub fn tick(&mut self, dt: Duration) {
        let dt_secs = dt.as_secs_f64();

        match self.mode {
            Mode::AwaitingTask => {
                // Idle state. Do nothing until a task is assigned.
                self.velocity = Vector3::zeros();
            }
            Mode::Planning => {
                if let Some(task) = &self.current_task {
                    // For now, planning is simple: just go to the target waypoint.
                    let target_point =
                        Self::api_to_nalgebra_point(task.target_waypoint_ecef_m.as_ref().unwrap());
                    self.current_plan = Some(Plan {
                        waypoints: vec![target_point],
                    });
                    self.mode = Mode::Navigating;
                    tracing::info!(plan = ?self.current_plan, "Planning complete, entering navigation mode");
                } else {
                    // No task, something is wrong. Revert to awaiting.
                    self.mode = Mode::AwaitingTask;
                }
            }
            Mode::Navigating => {
                if let Some(plan) = &self.current_plan {
                    if let Some(target) = plan.waypoints.first() {
                        let current_pos = self.pose.translation.vector;
                        let direction = target - Point3::from(current_pos);
                        let distance = direction.magnitude();

                        if distance < WAYPOINT_PROXIMITY_M {
                            // Reached waypoint
                            tracing::info!("Waypoint reached. Task complete.");
                            self.current_plan = None;
                            self.current_task = None;
                            self.mode = Mode::AwaitingTask;
                            self.velocity = Vector3::zeros();
                        } else {
                            // Move towards waypoint
                            self.velocity = direction.normalize() * AGENT_SPEED_MPS;
                            self.pose.translation.vector += self.velocity * dt_secs;
                            // TODO: Update orientation to face velocity vector
                            self.mode = Mode::Perceiving;
                        }
                    }
                } else {
                    // No plan, revert to awaiting.
                    self.mode = Mode::AwaitingTask;
                }
            }
            Mode::Perceiving => {
                // The actual perception (GPU scan) is done in the main loop.
                // This state immediately transitions back to Navigating to continue movement.
                self.mode = Mode::Navigating;
            }
            Mode::Shutdown => {
                // Agent is shutting down.
            }
        }
    }

    /// Creates an `AgentReport` from the current state and clears the discovery buffer.
    pub fn get_report_and_clear_buffer(&mut self) -> anyhow::Result<AgentReport> {
        let mut discovered_points_portable = Vec::new();
        self.discovery_buffer
            .serialize_into(&mut discovered_points_portable)?;
        self.discovery_buffer.clear();

        let report = AgentReport {
            agent_id: self.agent_id,
            timestamp_ms: chrono::Utc::now().timestamp_millis(),
            state: Some(ApiAgentState {
                agent_id: self.agent_id,
                timestamp_ms: chrono::Utc::now().timestamp_millis(),
                position_ecef_m: Some(Self::nalgebra_to_api_vec3m(
                    &self.pose.translation.vector,
                )),
                velocity_ecef_mps: Some(Self::nalgebra_to_api_vec3mps(&self.velocity)),
                orientation_ecef: Some(Self::nalgebra_to_api_quat(&self.pose.rotation)),
                mode: self.api_mode() as i32,
                sequence: self.sequence_number,
                schema_version: 1,
            }),
            discovered_point_ids_portable: discovered_points_portable,
        };

        self.sequence_number = self.sequence_number.wrapping_add(1);
        Ok(report)
    }

    /// Converts the internal `Mode` to the protobuf `ApiAgentMode`.
    pub fn api_mode(&self) -> ApiAgentMode {
        match self.mode {
            Mode::AwaitingTask => ApiAgentMode::AwaitingTask,
            Mode::Planning => ApiAgentMode::Planning,
            Mode::Navigating => ApiAgentMode::Navigating,
            Mode::Perceiving => ApiAgentMode::Perceiving,
            Mode::Shutdown => ApiAgentMode::Disconnected,
        }
    }

    // --- Conversion Helpers ---

    fn api_to_nalgebra_point(v: &Vec3m) -> Point3<f64> {
        Point3::new(v.x, v.y, v.z)
    }

    fn nalgebra_to_api_vec3m(v: &Vector3<f64>) -> Vec3m {
        Vec3m {
            x: v.x,
            y: v.y,
            z: v.z,
        }
    }

    fn nalgebra_to_api_vec3mps(v: &Vector3<f64>) -> Vec3mps {
        Vec3mps {
            x: v.x,
            y: v.y,
            z: v.z,
        }
    }

    fn nalgebra_to_api_quat(q: &NalgebraUnitQuaternion<f64>) -> UnitQuaternion {
        UnitQuaternion {
            w: q.w,
            x: q.i,
            y: q.j,
            z: q.k,
        }
    }
}
