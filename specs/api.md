IMPLEMENTED

#### **0.1. The `api` Crate**

*   **Purpose:** This crate is the foundational contract for the entire system. It contains all shared data structures and communication protocols, ensuring compile-time consistency across the workspace. It is the first component to be implemented and must be stable before significant work on other components begins.
*   **Contents:**
    1.  **`api/proto/v1/simulation.proto`:** The single source of truth for all gRPC and Protobuf message definitions. The full, final content is provided below.
    2.  **`api/build.rs`:** A build script utilizing `tonic-build` to generate Rust code from the `.proto` file.
    3.  **Generated Code:** The generated `api.v1.rs` file will be committed to the repository. This is a critical step to ensure that developers working on other components do not need to have the `protoc` compiler and its dependencies installed on their local machines.
*   **Developer "Day 1" Action:** All developers MUST pull the repository and successfully run `cargo build -p api` to ensure the shared contracts are available and compile correctly before starting work on their assigned component.
*   **Serialization Standard:** All `RoaringBitmap` data structures transmitted over the network MUST be serialized as Roaring portable bytes per the Roaring Format Specification.
    *   **Rust Crates:**
        *   `roaring` (pure Rust): Use `serialize_into(&mut Vec<u8>)` to produce portable bytes; deserialize with the corresponding crate deserializer.
        *   `croaring`/`croaring-sys`: Use the portable serializers (e.g., `try_serialize_into`) and the matching portable deserializers.

#### **0.2. `api/proto/v1/simulation.proto` (Definitive Contract)**
```protobuf
syntax = "proto3";

package api.v1;

// All linear distances are in metres (SI).
// All coordinate frames are Earth-Centered, Earth-Fixed (ECEF), EPSG:4978.
// All timestamps are Unix epoch milliseconds (UTC).
// All durations are in milliseconds.
// Trace context: All RPCs MUST propagate W3C traceparent/tracestate in gRPC metadata.
// Schema version fields MUST be 1 unless otherwise negotiated.

// A 3D vector in meters, ECEF frame (EPSG:4978).
message Vec3m {
  double x = 1;
  double y = 2;
  double z = 3;
}

// A 3D vector in meters per second, ECEF frame (EPSG:4978).
message Vec3mps {
  double x = 1;
  double y = 2;
  double z = 3;
}

// An orientation represented as a unit-norm quaternion in the ECEF frame (EPSG:4978).
// Invariants: ||q|| = 1 ± 1e-6, w ≥ 0 (canonical hemisphere).
message UnitQuaternion {
  double w = 1;
  double x = 2;
  double y = 3;
  double z = 4;
}

// The operational mode of an agent.
enum AgentMode {
  AWAITING_TASK = 0;
  PLANNING = 1;
  NAVIGATING = 2;
  PERCEIVING = 3;
  DISCONNECTED = 4;
}

// A snapshot of a single agent's state.
message AgentState {
  uint64 agent_id = 1;
  // Time the pose was sampled.
  int64 timestamp_ms = 2;
  Vec3m position_ecef_m = 3;
  Vec3mps velocity_ecef_mps = 4;
  UnitQuaternion orientation_ecef = 5;
  AgentMode mode = 6;
  // A monotonic sequence number, incremented by the agent for each state update.
  // Wraps modulo 2^32; receivers MUST handle unsigned wraparound.
  uint32 sequence = 7;
  // The version of this schema. MUST be 1.
  uint32 schema_version = 255;
}

// A task assigned by the orchestrator to an agent.
message Task {
  Vec3m target_waypoint_ecef_m = 1;
}

// === RegisterAgent RPC ===
message RegisterAgentRequest {
  // A UUIDv4 generated by the agent on startup, unique to its process lifetime.
  string session_id = 1;
  // A freeform string identifying the agent's software version.
  string sw_version = 2;
  // A freeform string identifying the agent's hardware profile.
  string hw_profile = 3;
}
message RegisterAgentResponse {
  // The unique, monotonic ID assigned by the orchestrator for this agent.
  uint64 agent_id = 1;
  // The server's current time, for clock synchronization hints.
  int64 server_time_ms = 2;
  // The desired interval for the agent to send AgentReport messages.
  uint32 report_interval_ms = 3;
  // The maximum size in bytes for a single AgentReport message.
  uint32 max_report_bytes = 4;
  // The version of this schema. MUST be 1.
  uint32 schema_version = 255;
}

// === ReportState RPC ===
message AgentReport {
  uint64 agent_id = 1;
  // Time the report was enqueued for send.
  int64 timestamp_ms = 2;
  // The agent's full state at the time of this report.
  AgentState state = 3;
  // The result of serializing a RoaringBitmap (portable format) for points
  // discovered since the last successful report.
  bytes discovered_point_ids_portable = 4;
}
message ReportStateResponse {
  // The orchestrator can assign a new task to the agent in this response.
  optional Task assigned_task = 1;
  // The version of this schema. MUST be 1.
  uint32 schema_version = 255;
}

// === SubscribeWorldState RPC ===
message SubscribeWorldStateRequest {
  // If true, the server will immediately send the current state upon subscription.
  bool include_initial_snapshot = 1;
  // The version of this schema. MUST be 1.
  uint32 schema_version = 255;
}
message WorldState {
  // Unix timestamp in milliseconds (UTC).
  int64 timestamp_ms = 1;
  repeated AgentState agents = 2;
  // An opaque ticket to be used in an Arrow Flight DoGet call
  // to retrieve the full reveal mask corresponding to this state.
  // This is NOT a UTF-8 string and must be treated as raw bytes.
  bytes reveal_mask_ticket = 3;
  // The ratio of revealed points to total points, from 0.0 to 1.0.
  double map_coverage_ratio = 4;
  // The version of this schema. MUST be 1.
  uint32 schema_version = 255;
}

// === IssueCommand RPC ===
message IssueCommandRequest {
  oneof command {
    StartSurveyCommand start_survey = 1;
    ResetSimulationCommand reset_simulation = 2;
  }
  // The version of this schema. MUST be 1.
  uint32 schema_version = 255;
}
message StartSurveyCommand {}
message ResetSimulationCommand {}

message IssueCommandResponse {
  bool acknowledged = 1;
  string message = 2; // e.g., "Command acknowledged" or an error message.
  // The version of this schema. MUST be 1.
  uint32 schema_version = 255;
}

// The main C2 Service Definition, exposed by the sim_orchestrator.
service SimulationC2 {
  // Called by a sim_agent on startup to join the simulation.
  rpc RegisterAgent(RegisterAgentRequest) returns (RegisterAgentResponse);

  // A long-lived, bidirectional RPC for a sim_agent to report its state
  // and discoveries, and for the orchestrator to send back tasks.
  rpc ReportState(stream AgentReport) returns (stream ReportStateResponse);

  // A long-lived, server-streaming RPC for a viewer to receive updates
  // on the state of the world.
  rpc SubscribeWorldState(SubscribeWorldStateRequest) returns (stream WorldState);

  // A unary RPC for a viewer to send commands to the simulation.
  rpc IssueCommand(IssueCommandRequest) returns (IssueCommandResponse);
}
```

#### **0.3. Project-Wide Logging Standard**

*   **Standard:** All components MUST use a structured logging framework, specifically `tracing`.
*   **Format:** Logs MUST be emitted as structured JSON to `stdout`. This allows for easy ingestion, parsing, and analysis by external logging systems.
*   **Required Fields:** Every log entry MUST, at a minimum, include:
    *   `timestamp`: ISO 8601 format.
    *   `level`: (e.g., `INFO`, `WARN`, `ERROR`).
    *   `message`: The log message.
    *   `component`: The name of the component (e.g., `sim_orchestrator`, `sim_agent`).
    *   `trace_id`, `span_id`: For distributed tracing context.
*   **Contextual Fields:** Developers MUST add relevant contextual fields to log entries (e.g., `agent_id`, `rpc_method`, `error_details`).
*   **Trace Context Propagation:** All gRPC calls MUST propagate W3C Trace Context (`traceparent`, `tracestate`) via gRPC metadata. The `tracing-opentelemetry` crate can be used to automate this.

#### **0.4. Project-Wide gRPC/HTTP2 Defaults (Normative)**

All gRPC servers and clients MUST configure HTTP/2 keep-alives and timeouts as follows:
*   **Servers (applies to `sim_orchestrator`):**
    *   `http2_keepalive_interval` = 30s
    *   `http2_keepalive_timeout` = 20s
    *   Optional: `tcp_keepalive` = 30s (OS-level)
*   **Clients (applies to `sim_agent` and `holographic-viewer`):**
    *   `keep_alive_while_idle` = `true`
    *   `http2_keepalive_interval` = 30s
    *   `http2_keepalive_timeout` = 20s
    *   Per-RPC default deadline (unary): 5s (viewer commands, registration)
    *   Stream liveness grace (bidi/server-stream): application-level watchdog > 90s (3× keepalive_interval) before declaring failure
*   **Implementation Note (Rust/tonic):** Set these on the transport server/client builders.

---
---

### **Component 4: `link_emulator` (The Network Proxy)**

(This section is the full, final specification for the `link_emulator` team.)

#### **4.1. Mission & Stakes**

*   **Mission:** To provide a realistic and configurable network test harness. Its purpose is to make the resilience and robustness of the distributed system a *demonstrable feature* rather than just a theoretical claim.
*   **Stakes:** **Credibility-Critical.** Without this component, the demonstration cannot effectively prove that the system handles intermittent connectivity or low-bandwidth conditions. It is the key that unlocks the ability to showcase the more advanced distributed systems concepts required by the role.

#### **4.2. Role & Motivation (The "Why")**

*   **Background:** Testing distributed systems against real-world network conditions is notoriously difficult. The `link_emulator` provides a simple, deterministic, and repeatable way to simulate these conditions, directly addressing the job description's points on "intermittent connectivity," "byzantine actors" (via packet loss), and "long-range low-bandwidth radios."
*   **Architectural Motivation:**
    *   **Transparent Proxy:** The choice of a transparent TCP proxy is crucial. It requires **zero code changes** in any of the other components. The viewer and agents are simply configured to point at the emulator's address instead of the orchestrator's. This makes it a modular, non-invasive tool that can be easily added or removed from the system for testing.
    *   **Simplicity and Focus:** The emulator focuses only on link-level impairments. It does not attempt to simulate complex network topologies or routing protocols. This keeps the component simple, robust, and focused on its core mission of testing the resilience of the application-level protocols (gRPC).

#### **4.3. Communication Paths & Dependencies**

*   **Ingress (Inputs):**
    1.  **From any client (`viewer`, `agent`):** Accepts any TCP connection on its listening port.
*   **Egress (Outputs):**
    1.  **To any server (`orchestrator`):** Creates a new TCP connection to its configured target address and forwards the data.
*   **Dependencies:**
    *   It is a dependency for any client that wishes to have its connection impaired.
    *   It depends on the target server being available on the network.

#### **4.4. Scope & Implementation Boundaries (In-Scope vs. Out-of-Scope)**

*   **IN-SCOPE:**
    *   Proxying arbitrary TCP traffic.
    *   Injecting latency, jitter, bandwidth caps (token bucket), and stall windows (periodic read/write pauses).
    *   **NOTE:** For true packet loss, duplication, corruption, or reordering, the operator MUST use an OS-level tool like Linux `tc netem`.
*   **OUT-OF-SCOPE (Explicitly Not To Be Implemented):**
    *   Proxying UDP traffic.
    *   Simulating network partitions between specific clients (all clients get the same impairment).
    *   Simulating DNS resolution issues or higher-level network phenomena.
    *   A dynamic configuration API. Configuration is set once at startup.

#### **4.5. Tooling & Key Dependencies**

*   **`tokio`:** For all asynchronous I/O operations.
*   **`rand`:** For simulating jitter and scheduling randomized stall windows.
*   **`tracing` & `tracing-subscriber`:** For structured, JSON-formatted logging.

#### **4.6. Lifecycle & State Management**

*   **Lifecycle:** The emulator is stateless. It starts, listens, proxies connections, and shuts down. It does not manage any state between connections.
*   **Multi-Instance Deployment Strategy:**
    *   The system architecture requires proxying multiple ports (gRPC and Arrow Flight). The `docker-compose.yml` file will be the definitive source for this configuration. It will define multiple `link_emulator` services, each with a unique name and configuration.
    *   **Example `docker-compose.yml` snippet:**
        ```yaml
        services:
          # ... orchestrator definition ...

          link-emulator-grpc:
            image: link-emulator:latest # Assumes a Docker image is built
            environment:
              - EMULATOR_LISTEN_ADDR=0.0.0.0:60051
              - EMULATOR_TARGET_ADDR=sim_orchestrator:50051
              - EMULATOR_LATENCY_MS=50
              # ... other impairment settings ...
            ports:
              - "60051:60051"

          link-emulator-flight:
            image: link-emulator:latest
            environment:
              - EMULATOR_LISTEN_ADDR=0.0.0.0:60052
              - EMULATOR_TARGET_ADDR=sim_orchestrator:50052
              - EMULATOR_RATE_BPS=131072
              - EMULATOR_BUCKET_BYTES=32768
              # ... other impairment settings ...
            ports:
              - "60052:60052"
        ```
    *   The `holographic-viewer` and `sim_agent` will be configured to connect to the emulator's ports (`60051`, `60052`), not the orchestrator's direct ports.

#### **4.7. Definitive External Contracts**

*   **gRPC API:** None. It is gRPC-agnostic and operates at the TCP layer.

*   **Metrics Exposed (Prometheus format on `/metrics`):**
    *   `proxy_active_connections`: `Gauge` - Number of currently active proxied connections.
    *   `proxy_bytes_transferred_total{direction}`: `Counter` - Total bytes transferred, labeled by direction (`client_to_server` or `server_to_client`).
    *   `proxy_stall_windows_total`: `Counter` - Total number of injected stall windows.
    *   `proxy_resets_injected_total`: `Counter` - Total number of injected connection resets.
    *   **Cardinality:** Per-agent series MUST be deleted on deregistration; follow `_total`/`_seconds`/`_bytes` conventions.

*   **Configuration (Environment Variables):**
    *   `EMULATOR_LISTEN_ADDR`: **Required.** e.g., `0.0.0.0:60051`
    *   `EMULATOR_TARGET_ADDR`: **Required.** e.g., `sim_orchestrator:50051`
    *   `EMULATOR_METRICS_LISTEN_ADDR`: **Required.** e.g., `0.0.0.0:9099`
    *   `EMULATOR_LATENCY_MS`: Default `0`.
    *   `EMULATOR_JITTER_MS`: Default `0`.
    *   `EMULATOR_RATE_BPS`: Default `0` (unlimited).
    *   `EMULATOR_BUCKET_BYTES`: Default `0` (unlimited).
    *   `EMULATOR_STALL_PERIOD_MS`: Default `0` (disabled).
    *   `EMULATOR_STALL_DURATION_MS`: Default `0` (disabled).
